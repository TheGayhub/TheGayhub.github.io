<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.akwing.cn</id>
    <title>Guapi</title>
    <updated>2019-06-21T05:20:38.120Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.akwing.cn"/>
    <link rel="self" href="https://www.akwing.cn/atom.xml"/>
    <subtitle>惟世之繁华如故,斟酌岁月如初</subtitle>
    <logo>https://www.akwing.cn/images/avatar.png</logo>
    <icon>https://www.akwing.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, Guapi</rights>
    <entry>
        <title type="html"><![CDATA[暑假集训——周赛1]]></title>
        <id>https://www.akwing.cn/post/shu-jia-ji-xun-zhou-sai-1</id>
        <link href="https://www.akwing.cn/post/shu-jia-ji-xun-zhou-sai-1">
        </link>
        <updated>2019-06-21T03:22:30.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="最短路最小生成树">最短路/最小生成树</h2>
]]></summary>
        <content type="html"><![CDATA[<h2 id="最短路最小生成树">最短路/最小生成树</h2>
<!-- more -->
<blockquote>
<p><strong>C - Borg Maze <a href="http://poj.org/problem?id=3026">POJ - 3026</a></strong></p>
</blockquote>
<p>BFS+最小生成树</p>
<p>比赛的时候想到了用 bfs求出每个点之间的最短距离，然后跑一遍MST。</p>
<p>可是想想复杂度高达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>4</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,然后放弃了。赛后看题解，确实是这种做法，比赛的时候还是要大胆一些</p>
<pre><code>    #include&lt;iostream&gt;
    #include&lt;cstdio&gt;
    #include&lt;algorithm&gt;
    #include&lt;string&gt;
    #include&lt;cstring&gt;
    #include&lt;cmath&gt;
    #include&lt;queue&gt;
    #include&lt;map&gt;
    using namespace std;
    const int N = 50 + 10;
    const int inf = 0x3f3f3f3f;
    int n, m;
    int fa[N*N];
    int a[N][N];
    int get(int x)
    {
    	if (x == fa[x])  return x;
    	return fa[x] = get(fa[x]);
    }
    struct E
    {
    	int u, v, w;
    	bool operator&lt;(const E &amp;other){
    		return w &lt; other.w;
    	}
    }edge[N*N*N*N];
    int tot,cas;
    int d[N][N];
    const int dx[4] = { 0, 0, -1, 1 }, dy[4] = { 1, -1, 0, 0 };
    typedef pair&lt;int, int &gt; P;
    void bfs(int x,int y)
    {
    	memset(d, -1, sizeof(d));
    	d[x][y] =0;
    	queue&lt;P&gt; q;
    	q.push(P(x, y));
    	int cnt = 1;
    	while (!q.empty())
    	{
    		P cur = q.front();
    		q.pop();
    		for (int i = 0; i &lt; 4; i++)
    		{
    			int nx = cur.first+ dx[i], ny = cur.second + dy[i];
    			if (nx &gt;= 1 &amp;&amp; nx &lt;= n&amp;&amp;ny &gt;= 1 &amp;&amp; ny &lt;= m&amp;&amp;d[nx][ny] == -1&amp;&amp;a[nx][ny]&gt;=0)
    			{
    				d[nx][ny] = d[cur.first][cur.second] + 1;
    				q.push(P(nx, ny));
    				if (a[nx][ny]&gt;0)
    				{
    					edge[tot].u = a[x][y];
    					edge[tot].v = a[nx][ny];
    					edge[tot].w = d[nx][ny];
    					tot++;
    					cnt++;
    					if (cnt &gt;= cas) return;
    				}
    			}
    		}
    	}
    }
    void kru()
    {
    	sort(edge, edge + tot);
    	for (int i = 1; i &lt;= cas; i++)
    		fa[i] = i;
    	int ans = 0;
    	int k = 0;
    	for (int i = 0; i &lt; tot; i++)
    	{
    		int u = edge[i].u, v = edge[i].v;
    		if (get(u) != get(v))
    		{
    			fa[get(u)] = get(v);
    			ans += edge[i].w;
    		}
    	}
    	cout &lt;&lt; ans &lt;&lt; endl;
    
    }
    int main()
    {
    	int t;
    	cin &gt;&gt; t;
    	while (t--)
    	{
    		tot = 0;
    		cas = 0;
    		cin &gt;&gt; m &gt;&gt; n;
    		char s[N];
    		gets(s);
    		for (int i = 1; i &lt;= n; i++)
    		{
    			for (int j = 1; j&lt;= m; j++)
    			{
    				char c = getchar();
    				if (c == ' ') a[i][j] = 0;
    				else if (c == '#') a[i][j] = -1;
    				else a[i][j] = ++cas;
    			}
    			getchar();
    		}
    		for (int i = 1; i &lt;= n; i++)
    		{
    			for (int j = 1; j &lt;= m; j++)
    			{
    				if (a[i][j] &gt; 0)
    					bfs(i, j);
    			}
    		}
    		kru();
    	}
    	return 0;
    }
</code></pre>
<p>[========]</p>
<blockquote>
<p>**D - 0 or 1   <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4370">HDU - 4370</a> **</p>
</blockquote>
<p>比赛的时候不会，赛后看题解也是挺懵的。
这题把C矩阵看成邻接表，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>  表示 i到j之间的距离，把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">X_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 看成 i到j之间的关系，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">X_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 为1则表示i和j之间有一条路，并且权值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>
这样我们求从1到n的最短路就可以得到  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mi>C</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo>∗</mo><mi>X</mi><mrow><mi>i</mi><mi>j</mi></mrow></mrow><annotation encoding="application/x-tex">\sum C{ij} * X{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></span> ， 为什么这样是正确的呢？
我们把每行每列(邻接表) 看成是图的一个顶点，我们可以观察到第一行的出度就是1，最后一列的入度是1，其他点的出度和入度均为1</p>
<ul>
<li>表示点 1 的出度为 1</li>
<li>表示点 n 的入度为 1</li>
<li>除了点 1 和点 n 外的其他点出入度相等</li>
</ul>
<p>可以画一下，发现从一个点u到另一个点v就是邻接表 <code>C[u][v]</code> ,这样会使第V列多一个1，然后我们下次再从第V行出发在找下一个点，这样第V行也就多一个1，这样就满足了题目要求的关系。
然后还有一种情况，那就是可以从点 1 出发到达其他点然后又回到点 1 形成一个环，同样也可以从点 n 出发回到点 n。这样也是符合条件的，答案为从 1 出发的最小权值环和从 n 出发的最小权值环之和。
最后比较两种情况的最小值
求环，注意最开始不是将起点 s 入队，而是把与起点相连的点加入队列，将 <code>dis[s]</code> 设为 <code>inf</code> 这样可以求得从 s 出发回到 s 的最小环，具体参考代码。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
const int N = 310;
const int inf = 0x3f3f3f3f;
int dis[N];
bool vis[N];
int a[N][N],n;
void spfa(int st)
{
	queue&lt;int&gt; q;
	memset(vis, false, sizeof(vis));
	memset(dis, inf, sizeof(dis));
	for (int i = 1; i &lt;= n; i++)
	{
		if (i == st)
		{
			dis[i] = inf;
		}
		else
		{
			q.push(i);
			vis[1] = true;
			dis[i] = c[st][i];
		}
	}
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		vis[u] = false;
		for (int v = 1; v &lt;= n; v++)
		{
			if (dis[v] &gt; dis[u] + c[u][v])
			{
				dis[v] = dis[u] +c[u][v];
				if (!vis[v])
				{
					vis[v] = true;
					q.push(v);
				}
			}

		}


	}
}
int main()
{
	while (scanf(&quot;%d&quot;, &amp;n)!=EOF)
	{
		
		for (int i = 1; i &lt;= n; i++)
		{
			for (int j = 1; j &lt;= n; j++)
				scanf(&quot;%d&quot;, &amp;c[i][j]);
		}
		spfa(1);
		int c1 = dis[1], ans = dis[n];
		spfa(n);
		int c2 = dis[n];
		ans = min(ans, c1 + c2);
		cout &lt;&lt; ans &lt;&lt; endl;

	}
	return 0;
}
</code></pre>
<hr>
<blockquote>
<p>**E - Extended Traffic <a href="https://vjudge.net/problem/LightOJ-1074">LightOJ - 1074</a> **</p>
</blockquote>
<p>spfa判负环，把负环上的点标记一下，不要想当然的认为有负环所有点都要被标记，负环只是所有点形成的图的一部分，还有就是不要忘了in[v]++,赛场上这个地方没写超时了，也没来得及发现</p>
<pre><code>#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int M = 2e5 + 10;
const int N = 2e2 + 10;
const int inf = 0x3f3f3f3f;
struct E{
	int to, next, w;
}edge[M];
int head1[N], tot;
int dis1[N], in[N];
bool vis[N], vis1[N];
int n, m, cas;
int a[N];
void addedge(int from, int to, int w)
{
	edge[++tot].to = to;
	edge[tot].w = w;
	edge[tot].next = head1[from];
	head1[from] = tot;
}
void dfs(int u)
{
	vis1[u] = true;
	for (int i = head1[u]; i != -1; i = edge[i].next)
	{
		if (!vis1[edge[i].to])
			dfs(edge[i].to);
	}
}
bool spfa1()
{
	int h = 0, t = 0;
	queue&lt;int&gt; q;
	memset(dis1, inf, sizeof(dis1));
	memset(vis, false, sizeof(vis));
	memset(vis1, false, sizeof(vis1));
	memset(in, 0, sizeof(in));
	dis1[1] = 0;
	q.push(1);
	in[1]++;
	vis[1] = true;
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		vis[u] = false;
		if (vis1[u]) continue;
		for (int i = head1[u]; i != -1; i = edge[i].next)
		{
			int v = edge[i].to;
			
			int w = edge[i].w;
			if (dis1[v]&gt; dis1[u] + w)
			{
				dis1[v] = dis1[u] + w;
				if (!vis[v])
				{
					vis[v] = true;
					q.push(v);
					in[v]++;
					if (in[v] &gt; n) vis1[v]=true;
				}
			}
		}
	}
	return true;
}

int main()
{
	int t;
	cin &gt;&gt; t;
	while (t--)
	{
		tot = 0;
		scanf(&quot;%d&quot;, &amp;n);
		for (int i = 1; i &lt;= n; i++)
		{
			scanf(&quot;%d&quot;, &amp;a[i]);
			head1[i] = -1;
		}
		cin &gt;&gt; m;
		while (m--)
		{
			int u, v;
			scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
			int w = (a[v] - a[u])*(a[v] - a[u])*(a[v] - a[u]);
			addedge(u, v, w);
		}
		bool f=spfa1();
		printf(&quot;Case %d:\n&quot;, ++cas);
		int q;
		scanf(&quot;%d&quot;, &amp;q);
		while (q--)
		{
			int vv;
			scanf(&quot;%d&quot;, &amp;vv);
			if (vis1[vv] || dis1[vv] == inf || dis1[vv] &lt; 3)
			{
				puts(&quot;?&quot;);
			}
			else
			{
				printf(&quot;%d\n&quot;, dis1[vv]);
			}


		}
	}


	return 0;
}
</code></pre>
<hr>
<blockquote>
<p><strong>F - The Unique MST <a href="http://poj.org/problem?id=1679">POJ - 1679</a></strong></p>
</blockquote>
<p>这题判断最小生成树是否唯一，用kruskal 加边的时候如果两个顶点在一个集合中了，判断已加入的顶点集合中是否存在和当前边权值相同的边，有就是不唯一。可以把加入集合中的点建一颗树，然后搜索进行判断。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
using namespace std;
const int N = 1e3 + 10;
const int inf = 0x3f3f3f3f;
int n, m;
int fa[N];
int get(int x)
{
	if (x == fa[x])  return x;
	return fa[x] = get(fa[x]);
}
struct E
{
	int u, v, w;
	bool operator&lt;(const E &amp;other){
		return w &lt; other.w;
	}
}edge[N*N];
int tot;
int a[N];
typedef pair&lt;int, int&gt; P;
vector&lt;P&gt; g[N];
bool dfs(int v, int u,int pre, int c,bool f)
{
	for (int i = 0; i &lt; g[v].size(); i++)
	{
		if (g[v][i].first == pre) continue;
		if (g[v][i].second == c)  f = true;
		if (f&amp;&amp;g[v][i].first == u) return true;
		if	(dfs(g[v][i].first, u, v, c, f)) return true;
	}
	return false;
}
int main()
{
	int t;
	cin &gt;&gt; t;
	while (t--)
	{
		cin &gt;&gt; n;
		for (int i = 1; i &lt;= n; i++)
			g[i].clear();
		cin &gt;&gt; m;
		tot = 0;
		bool f = true;
		while (m--)
		{
			int i, j, w;
			cin &gt;&gt; i &gt;&gt; j &gt;&gt; w;
			edge[tot].w = w;
			edge[tot].u = i;
			edge[tot].v = j;
			tot++;
		}
		sort(edge, edge + tot);
		for (int i = 1; i &lt;= n; i++)
			fa[i] = i;
		int ans = 0;
		int k = 0;
		for (int i = 0; i &lt; tot; i++)
		{
			if (k &gt;= n - 1) break;
			int u = edge[i].u, v = edge[i].v;
			if (get(u) != get(v))
			{
				g[u].push_back(P(v, edge[i].w));
				g[v].push_back(P(u, edge[i].w));
				fa[get(u)] = get(v);
				ans += edge[i].w;
			}
			else
			{
				
				if (dfs(u, v, -1, edge[i].w, false)) {
					f = false;
					break;
				}
				
			}
		}
		if (f)
			printf(&quot;%d\n&quot;, ans);
		else
			printf(&quot;Not Unique!\n&quot;);
	}
	return 0;
}
</code></pre>
<blockquote>
<p>总结:比赛的时候一定要细心，有思路的时候要尝试去实现它！！！多刷题。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[POJ 3662 Telephone Lines]]></title>
        <id>https://www.akwing.cn/post/poj-3662-telephone-lines</id>
        <link href="https://www.akwing.cn/post/poj-3662-telephone-lines">
        </link>
        <updated>2019-06-19T12:35:40.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="dp二分-最短路">DP/二分 + 最短路</h2>
]]></summary>
        <content type="html"><![CDATA[<h2 id="dp二分-最短路">DP/二分 + 最短路</h2>
<!-- more -->
<blockquote>
<p>方法1 DP</p>
</blockquote>
<p><strong><code>用d[x][y]表示从1号节点到达x号节点,途中经过了y条免费电缆时,经过的路上最贵的电缆花费最小是多少.</code></strong>
假设有一条边从 <code>x</code> 到 <code>v</code> ，权值为 <code>w</code> ，则我们可以：</p>
<ul>
<li>用 <code>max(dp[x][y],w)</code> 更新 <code>dp[v][y]</code> ,这个表示不在电缆 <code>x-v</code> 使用免费服务。</li>
<li>用 <code>dp[x][y]</code> 更新 <code>dp[v][p+1]</code> ,表示在电缆 <code>x-v</code> 上使用免费服务</li>
</ul>
<p>由于这个dp有后效性，不能用dij，采用spfa不断迭代更新。</p>
<pre><code>#include &lt;bits/stdc++.h&gt;//缩短代码用了万能头，poj不允许这样
using namespace std;
const int N = 1e3 + 10;
const int inf = 0x3f3f3f3f;
int n, pp, k;
struct E{
	int to, next, w;
}edge[20 * N];
int tot;
int head[N];
bool vis[N][N];
int dp[N][N];
void addedge(int from, int to, int w)
{
	edge[++tot].to = to;
	edge[tot].w = w;
	edge[tot].next = head[from];
	head[from] = tot;
}
typedef pair&lt;int, int&gt; P;
queue&lt;P&gt; q;
void spfa()
{
	memset(dp, inf, sizeof(dp));
	dp[1][0] = 0;
	vis[1][0] = true;
	q.push(P(1, 0));
	while (!q.empty())
	{
		P u = q.front();
		q.pop();
		int x = u.first, p = u.second;
		vis[x][p] = false;
		for (int i = head[x]; i != -1; i = edge[i].next)
		{
			int v = edge[i].to, w = edge[i].w;
			if (dp[v][p]&gt;max(dp[x][p], w))
			{
				dp[v][p] = max(dp[x][p], w);
				if (!vis[v][p])
				{
					vis[v][p] = true;
					q.push(P(v, p));
				}
			}
			if (p&lt;k&amp;&amp;dp[v][p + 1]&gt;dp[x][p])
			{
				dp[v][p + 1] = dp[x][p];
				if (!vis[v][p + 1])
				{
					vis[v][p + 1] = true;
					q.push(P(v, p + 1));
				}
			}
		}
	}

}
int main()
{
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;pp, &amp;k);
	memset(head, -1, sizeof(head));
	while (pp--)
	{
		int u, v, w;
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
		addedge(u, v, w);
		addedge(v, u, w);
	}
	spfa();
	int ans = inf;
	for (int i = 0; i &lt;= k; i++)
	{
		ans = min(ans, dp[n][i]);
	}
	printf(&quot;%d\n&quot;, ans == inf ? -1 : ans);
	return 0;
}
</code></pre>
<blockquote>
<p>方法2 二分</p>
</blockquote>
<p>显然答案具有单调性。二分答案，假设答案为mid，我们将边权大于等于mid的边的边权设为1，表示免费服务的边，即可以理解为使用了一次免费服务。小于mid的边权设为0，表示不免费，没有使用免费服务。然后我们跑一便最短路，看最短路径是否小于等于K，小于等于则mid是满足的，我们可以缩小mid,继续二分答案。</p>
<pre><code>#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1e3 + 10;
const int inf = 0x3f3f3f3f;
int n, pp, k;
struct E{
	int to, next, w;
}edge[20 * N];
int tot;
int head[N];
bool vis[N];
int dis[N];
void addedge(int from, int to, int w)
{
	edge[++tot].to = to;
	edge[tot].w = w;
	edge[tot].next = head[from];
	head[from] = tot;
}
typedef pair&lt;int, int&gt; P;
queue&lt;int&gt; q;
int spfa(int mid)
{
	while (!q.empty()) q.pop();
	memset(vis, false, sizeof(vis));
	memset(dis, inf, sizeof(dis));
	dis[1] = 0;
	vis[1] = true;
	q.push(1);
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		vis[u] = false;
		for (int i = head[u]; i != -1; i = edge[i].next)
		{
			int v = edge[i].to;
			int w = (edge[i].w &gt;= mid);
			if (dis[v] &gt; dis[u]+ w)
			{
				dis[v] = dis[u] + w;
				if (!vis[v])
				{
					vis[v]= true;
					q.push(v);
				}
			}
		}
	}
	return dis[n] &lt;= k;
}
int main()
{
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;pp, &amp;k);
	memset(head, -1, sizeof(head));
	int l = 0;
	while (pp--)
	{
		int u, v, w;
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
		addedge(u, v, w);
		addedge(v, u, w);
	}
	int r = 1e7;
	while (l &lt; r)
	{
		int mid = (l+r+1) &gt;&gt; 1;
		if (!spfa(mid)) l = mid;
		else r = mid - 1;
	}
	printf(&quot;%d\n&quot;, l &gt;=1e7 ? -1 : l);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[E. Minimal Segment Cover]]></title>
        <id>https://www.akwing.cn/post/e-minimal-segment-cover</id>
        <link href="https://www.akwing.cn/post/e-minimal-segment-cover">
        </link>
        <updated>2019-06-15T07:24:56.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1175/problem/E">Minimal Segment Cover</a></p>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define x first
#define y second
#define forn(i, n) for(int i = 0; i &lt; int(n); i++) 

const int N = 500 * 1000 + 13;
const int LOGN = 18;

int n, m;
pair&lt;int, int&gt; a[N], q[N];

int nxt[N];
int up[LOGN][N];

int main(){
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	forn(i, n)
		scanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].y);
	forn(i, m)
		scanf(&quot;%d%d&quot;, &amp;q[i].x, &amp;q[i].y);
	
	sort(a, a + n);
	
	int lst = 0;
	pair&lt;int, int&gt; mx(0, -1);
	forn(i, N){
		while (lst &lt; n &amp;&amp; a[lst].x == i){
			mx = max(mx, make_pair(a[lst].y, lst));
			++lst;
		}
		nxt[i] = (mx.x &lt;= i ? -1 : mx.y);
	}
	
	forn(i, n)
		up[0][i] = nxt[a[i].y];
	for (int j = 1; j &lt; LOGN; ++j) forn(i, n){
		if (up[j - 1][i] == -1)
			up[j][i] = -1;
		else
			up[j][i] = up[j - 1][up[j - 1][i]];
	}
	
	forn(i, m){
		int x = nxt[q[i].x];
		
		if (x == -1){
		puts(&quot;-1&quot;);
		continue;
		}
		
		int res = 0;
		for (int j = LOGN - 1; j &gt;= 0; --j){
			int y = up[j][x];
			if (y == -1)
				continue;
			if (a[y].y &lt; q[i].y){
				res += (1 &lt;&lt; j);
				x = y;
			}
		}
		
		if (a[x].y &gt;= q[i].y)
			printf(&quot;%d\n&quot;, res);
		else if (up[0][x] == -1)
			puts(&quot;-1&quot;);
		else
			printf(&quot;%d\n&quot;, res + 1);
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HDU 5710 Digit-Sum]]></title>
        <id>https://www.akwing.cn/post/hdu-5710-digit-sum</id>
        <link href="https://www.akwing.cn/post/hdu-5710-digit-sum">
        </link>
        <updated>2019-06-11T05:37:36.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="构造">构造</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="构造">构造</h1>
<!-- more -->
<p><img src="https://www.akwing.cn/post-images/1560233194009.png" alt=""></p>
<p>很容易发现，当 2 * n 每进1位的时候，与 2 * S(n)的差就会少去9，这也可以推出来，因为满10进1，每进1位就会少10，得到1，所以每进1位就会少9.所以当n的数位上出现[5-9]时，乘于2就会少9，假设n的所有位上一共有L个[5-9]的数
我们可以得到 <code>S(2n)=2*S(n)-L*9</code>  再由 <code>a×S(n)=b×S(2n)</code> ,所以 <code>L/S(n)=(2*b-a)/(9*b)</code> 。(注意要上下同除gcd)
所以我们可以让 <code>L=2*b-a,S(n)=9*b</code> ,那如何贪心构造出最小的n呢？
我们先让n中的L位数全为5，即  xxx555(L个5)，S(n)-5 * L,然后剩下的S(n)再从末尾不断的加上去。
当<code>L&lt;0||5 * L&gt;S(n)</code> 的时候就是无解。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 2e5 + 10;
int a, b;
int gcd(int a, int b)
{
    if (b == 0) return a;
    return gcd(b, a%b);
}
int ans[N];
int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        int d = gcd(a, b);
        a /= d, b /= d;
        int l = 2 * b - a, sn = 9 * b;
        if (l&lt;0 || l * 5&gt;sn){
            puts(&quot;0&quot;);
            continue;
        }
        d = gcd(l, sn);
        l /= d, sn /= d;
        int tot = 0;
        sn -= 5 * l;
        for (int i = 0; i &lt; l; i++)
        {
            int tmp = min(4, sn);
            ans[tot++] = 5 + tmp;
            sn -= tmp;
        }
        while (sn)
        {
            int tmp = min(4, sn);
            ans[tot++] = tmp;
            sn -= tmp;
        }
        for (int i = tot - 1; i &gt;= 0; i--)
            cout &lt;&lt; ans[i];
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZOJ 2112 Dynamic Rankings ]]></title>
        <id>https://www.akwing.cn/post/zoj-2112-dynamic-rankings</id>
        <link href="https://www.akwing.cn/post/zoj-2112-dynamic-rankings">
        </link>
        <updated>2019-06-10T06:08:02.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="树状数组套主席树">树状数组套主席树</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="树状数组套主席树">树状数组套主席树</h1>
<!-- more -->
<p>之前学了主席树，解决了静态区间第k大，想着顺便学习一下如何求解动态区间第k大，奈何太菜，看了一晚上未能很好的理解，主要就是询问的时候卡住了我。第二天终于理解了。
这里给出两种方法</p>
<ul>
<li>方法1</li>
</ul>
<p>前缀和建树(和静态主席树一样)，树状数组更新，<strong>树状数组只保存更新带来的影响</strong>，每次查询左孩子区间sum的时候需要同时查询 <strong>(原来的值+树状数组的影响)</strong></p>
<ul>
<li>方法2</li>
</ul>
<p>类似树状数组的方式建树，<code>T[i]</code> 只保存区间<code>[i-lowbit(i)+1,i]</code>内的个数， 更新和查询都类似树状数组,这里树状数组直接保存了更新后的结果，<strong>因此询问时只需查询树状数组</strong>。</p>
<p>方法1的代码在洛谷和ZOJ都能过，方法2就只能过洛谷，ZOJ一直SF。</p>
<blockquote>
<p>方法1</p>
</blockquote>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define lowbit(x) (x&amp;(-x))
typedef long long ll;
const int N = 6e4 + 10;
const int M = 2500000;
int a[N], b[N * 2], tot, n, m, q, numx, numy;
struct query{
	int op, l, r, v;
}p[10005];
struct tree{
	int lc, rc, cnt;
}T[N * 32];
int root[N];
int ux[50], uy[50];
int S[N];
void build(int &amp;rt, int l, int r)
{
	rt = ++tot;
	T[rt].cnt = 0;
	T[rt].lc = T[rt].rc = 0;
	if (l == r) return;
	int mid = (l + r) &gt;&gt; 1;
	build(T[rt].lc, l, mid);
	build(T[rt].rc, mid + 1, r);
}
void update(int &amp;cur, int pre, int l, int r, int pos, int val)
{
	cur = ++tot;
	T[cur] = T[pre];
	T[cur].cnt += val;
	if (l == r) return;
	int mid = (l + r) &gt;&gt; 1;
	if (pos &lt;= mid) update(T[cur].lc, T[pre].lc, l, mid, pos, val);
	else update(T[cur].rc, T[pre].rc, mid + 1, r, pos, val);
}
void add(int pos, int val)
{
	int npos = lower_bound(b + 1, b + m + 1, a[pos]) - b;
	for (; pos &lt;= n; pos += lowbit(pos))
		update(S[pos], S[pos], 1, m, npos, val);
}
int query(int l, int r, int x, int y, int k)
{
	if (l == r) return l;
	int mid = (l + r) &gt;&gt; 1;
	int sum = 0;
	for (int j = 0; j &lt; numx; j++) sum -= T[T[ux[j]].lc].cnt;
	for (int j = 0; j &lt; numy; j++) sum += T[T[uy[j]].lc].cnt;
	sum += T[T[y].lc].cnt - T[T[x].lc].cnt;
	if (k&gt;sum)
	{
		for (int j = 0; j &lt; numx; j++)
			ux[j] = T[ux[j]].rc;
		for (int j = 0; j &lt; numy; j++)
			uy[j] = T[uy[j]].rc;
		return query(mid + 1, r, T[x].rc, T[y].rc, k - sum);
	}
	else
	{
		for (int j = 0; j &lt; numx; j++)
			ux[j] = T[ux[j]].lc;
		for (int j = 0; j &lt; numy; j++)
			uy[j] = T[uy[j]].lc;
		return query(l, mid, T[x].lc, T[y].lc, k );
	}
	
	
}
int main()
{
	int t;
	scanf(&quot;%d&quot;, &amp;t);
	while (t--)
	{
		tot = 0;
		m = 0;
		scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
		for (int i = 1; i &lt;= n; i++)
		{
			scanf(&quot;%d&quot;, &amp;a[i]);
			b[++m] = a[i];
		}
		for (int i = 1; i &lt;= q; i++)
		{
			char op[5];
			scanf(&quot;%s&quot;, op);
			if (op[0] == 'Q')
			{
				scanf(&quot;%d%d%d&quot;, &amp;p[i].l, &amp;p[i].r, &amp;p[i].v);
				p[i].op = 1;
			}
			else
			{
				scanf(&quot;%d%d&quot;, &amp;p[i].l, &amp;p[i].r);
				b[++m] = p[i].r;
				p[i].op = 2;
			}
		}
		sort(b + 1, b + m + 1);
		m = unique(b + 1, b + m + 1) - b - 1;
		build(root[0], 1, m);
		for (int i = 1; i &lt;= n; i++)
		{
			int pos = lower_bound(b + 1, b + m + 1, a[i]) - b;
			update(root[i], root[i - 1], 1, m, pos, 1);
		}
		for (int i = 0; i &lt;= n; i++)
			S[i] = root[0];
		for (int i = 1; i &lt;= q; i++)
		{
			if (p[i].op == 1)
			{
				numx = 0, numy = 0;
				for (int j = p[i].l - 1; j &gt; 0; j -= lowbit(j)) ux[numx++] = S[j];
				for (int j = p[i].r; j &gt; 0; j -= lowbit(j)) uy[numy++] = S[j];
				int ans = query(1, m, root[p[i].l - 1], root[p[i].r], p[i].v);
				printf(&quot;%d\n&quot;, b[ans]);
			}
			else
			{
				add(p[i].l, -1);
				a[p[i].l] = p[i].r;
				add(p[i].l, 1);
			}
		}

	}

	return 0;
}

</code></pre>
<blockquote>
<p>方法2(顺便来个非递归查询和更新)</p>
</blockquote>
<pre><code>// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define lowbit(x) (x&amp;(-x))
typedef long long ll;
const int N = 1e5+ 10;
const int M = 2500000;
int a[N], b[N*2], tot, n, m, q,numx,numy;
struct query{
    int op, l, r, v;
}p[100005];
struct tree{
    int lc, rc, cnt;
}T[N&lt;&lt;9];
int root[N];
int ux[50], uy[50];
void build(int &amp;rt,int l,int r)
{
    rt = ++tot;
    T[rt].cnt = 0;
    T[rt].lc = T[rt].rc = 0;
    if (l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    build(T[rt].lc, l, mid);
    build(T[rt].rc, mid + 1, r);
}
void update(int &amp;cur, int pre,int l, int r,int pos,int val)
{
    cur = ++tot;
    T[cur] = T[pre];
    T[cur].cnt += val;
    int tmp = cur;
    while (l &lt; r)
    {
        int mid = (l + r) &gt;&gt; 1;
        if (pos &lt;= mid)
        {
            T[tmp].lc = ++tot;
            T[tmp].rc = T[pre].rc;
            pre = T[pre].lc;
            tmp = T[tmp].lc;
            r = mid;
        }
        else
        {
            T[tmp].rc = ++tot;
            T[tmp].lc = T[pre].lc;
            pre = T[pre].rc;
            tmp = T[tmp].rc;
            l = mid + 1;
        }
        T[tmp].cnt = T[pre].cnt + val;
    }
    return;
}
void add(int pos, int val)
{
    int npos = lower_bound(b + 1, b + m + 1, a[pos]) - b;
    for (; pos &lt;= n; pos += lowbit(pos))
        update(root[pos], root[pos], 1, m, npos, val);
}
int query(int l,int r,int k)
{
    while (l &lt; r)
    {
        int mid = (l + r) &gt;&gt; 1;
        int sum = 0;
        for (int j = 0; j &lt; numx; j++) sum -= T[T[ux[j]].lc].cnt;
        for (int j = 0; j &lt; numy; j++) sum += T[T[uy[j]].lc].cnt;
        if (k&gt;sum)
        {
            k -= sum;
            for (int j = 0; j &lt; numx; j++)
                ux[j] = T[ux[j]].rc;
            for (int j = 0; j &lt; numy; j++)
                uy[j] = T[uy[j]].rc;
            l = mid + 1;
        }
        else
        {
            for (int j = 0; j &lt; numx; j++)
                ux[j] = T[ux[j]].lc;
            for (int j = 0; j &lt; numy; j++)
                uy[j] = T[uy[j]].lc;
            r = mid;
        }
    }

    return l;
}
int main()
{
    tot = 0;
    m = 0;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
    for (int i = 1; i &lt;= n; i++)
    {
        scanf(&quot;%d&quot;, &amp;a[i]);
        b[++m] = a[i];
    }
    for (int i = 1; i &lt;= q; i++)
    {
        char op[5];
        scanf(&quot;%s&quot;, op);
        if (op[0] == 'Q')
        {
            scanf(&quot;%d%d%d&quot;, &amp;p[i].l, &amp;p[i].r, &amp;p[i].v);
            p[i].op = 1;
        }
        else
        {
            scanf(&quot;%d%d&quot;, &amp;p[i].l, &amp;p[i].r);
            b[++m] = p[i].r;
            p[i].op = 2;
        }
    }
    sort(b + 1, b + m + 1);
    m = unique(b + 1, b + m + 1) - b - 1;
    for (int i = 1; i &lt;= n; i++)
        add(i, 1);
    for (int i = 1; i &lt;= q; i++)
    {
        if (p[i].op == 1)
        {
            numx = 0, numy = 0;
            for (int j = p[i].l-1; j &gt; 0; j -= lowbit(j)) ux[numx++] = root[j];
            for (int j = p[i].r; j &gt; 0; j -= lowbit(j)) uy[numy++] = root[j];
            int ans = query(1, m, p[i].v);
            printf(&quot;%d\n&quot;, b[ans]);
        }
        else
        {
            add(p[i].l, -1);
            a[p[i].l] = p[i].r;
            add(p[i].l, 1);
        }
    }

    return 0;
}

			
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[尺取法小合集]]></title>
        <id>https://www.akwing.cn/post/chi-qu-fa-xiao-he-ji</id>
        <link href="https://www.akwing.cn/post/chi-qu-fa-xiao-he-ji">
        </link>
        <updated>2019-05-10T08:34:30.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="尺取法">尺取法</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="尺取法">尺取法</h1>
<!-- more -->
<h3 id="尺取法顾名思义像尺子一样取一段借用挑战书上面的话说尺取法通常是对数组保存一对下标即所选取的区间的左右端点然后根据实际情况不断地推进区间左右端点以得出答案-之所以需要掌握这个技巧是因为尺取法比直接暴力枚举区间效率高很多尤其是数据量大的">尺取法：顾名思义，像尺子一样取一段，借用挑战书上面的话说，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。之所以需要掌握这个技巧，是因为尺取法比直接暴力枚举区间效率高很多，尤其是数据量大的</h3>
<h3 id="时候所以尺取法是一种高效的枚举区间的方法一般用于求取有一定限制的区间个数或最短的区间等等-当然任何技巧都存在其不足的地方有些情况下尺取法不可行无法得出正确答案">时候，所以尺取法是一种高效的枚举区间的方法，一般用于求取有一定限制的区间个数或最短的区间等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案。</h3>
<h3 id="使用尺取法时应清楚以下四点">使用尺取法时应清楚以下四点：</h3>
<h3 id="1-什么情况下能使用尺取法-2-何时推进区间的端点-3-如何推进区间的端点-3-何时结束区间的枚举">1、  什么情况下能使用尺取法?  2、何时推进区间的端点？ 3、如何推进区间的端点？ 3、何时结束区间的枚举？</h3>
<h3 id="尺取法通常适用于选取区间有一定规律或者说所选取的区间有一定的变化趋势的情况通俗地说在对所选取区间进行判断之后我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间如果已经判断了目前所选取的区间但却无法确定所要求解的区间如何进一步得到根据其端点得到那么尺取法便是不可行的-首先明确题目所需要求解的量之后区间左右端点一般从最整个数组的起点开始之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案">尺取法通常适用于选取区间有一定规律，或者说所选取的区间有一定的变化趋势的情况，通俗地说，在对所选取区间进行判断之后，我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间，如果已经判断了目前所选取的区间，但却无法确定所要求解的区间如何进一步得到根据其端点得到，那么尺取法便是不可行的。首先，明确题目所需要求解的量之后，区间左右端点一般从最整个数组的起点开始，之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案。</h3>
<h3 id="总结尺取法的模型便是这样根据区间的特征交替推进左右端点求解问题其高效的原因在于避免了大量的无效枚举其区间枚举都是根据区间特征有方向的枚举如果胡乱使用尺取法的话会使得枚举量减少因而很大可能会错误所以关键的一步是进行问题的分析">总结：尺取法的模型便是这样：根据区间的特征交替推进左右端点求解问题，其高效的原因在于避免了大量的无效枚举，其区间枚举都是根据区间特征有方向的枚举，如果胡乱使用尺取法的话会使得枚举量减少，因而很大可能会错误，所以关键的一步是进行问题的分析</h3>
<p><a href="https://blog.csdn.net/lxt_lucia/article/details/81091597">来自</a></p>
<!-- more -->
<blockquote>
<p><a href="http://poj.org/problem?id=3061">POJ 3061 Subsequence</a></p>
</blockquote>
<pre><code>
#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 1e5 + 10;
int n, s,a[N];
int main(){
	int t;
	cin &gt;&gt; t;
	while (t--)
	{
		scanf(&quot;%d%d&quot;, &amp;n,&amp;s);
		for (int i = 1; i &lt;= n; i++)
			scanf(&quot;%d&quot;, &amp;a[i]);
		int st = 1, en = 1;
		int tot = 0;
		int ans = n+10;
		while (1)
		{
			while (en &lt;= n&amp;&amp;tot &lt; s)
				tot += a[en++];
			if (tot &lt; s)
				break;
			ans = min(ans, en - st);
			tot -= a[st++];
		}
		if (ans == n + 10) printf(&quot;0\n&quot;);
		else 
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}
</code></pre>
<blockquote>
<p><a href="http://poj.org/problem?id=3320">POJ 3320 Jessica's Reading Problem</a>
求最小的页数覆盖所有知识点</p>
</blockquote>
<pre><code>
#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;
const int N = 1e6 + 10;
int n,a[N];
set&lt;int&gt; s;
map&lt;int, int&gt; cnt;
int main(){
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++)
		scanf(&quot;%d&quot;, &amp;a[i]),s.insert(a[i]);
	int sum = s.size();
	int st = 1, en = 1, tot = 0;
	int ans = n;
	while (1)
	{
		while (en &lt;= n&amp;&amp;tot &lt; sum){
			if (cnt[a[en]] == 0){
				tot++;
			}
			cnt[a[en++]]++;
		}
		if (tot &lt; sum) break;
		ans = min(ans, en - st);
		--cnt[a[st]];
		if (cnt[a[st++]] == 0) tot--;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
<blockquote>
<p><a href="http://poj.org/problem?id=2566">POJ 2566 Bound Found</a>
给定一个数组和一个值t，求一个子区间使得其和的绝对值与t的差值最小，如果存在多个，任意解都可行。</p>
</blockquote>
<pre><code>
#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;
const int N = 1e5 + 10;
const int INF = 1e9 + 10;
int n,k,t,a[N];
typedef pair&lt;int, int&gt; P;
P s[N];
int main()
{
	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) &amp;&amp; (n || k))
	{
		s[0] = P(0, 0);
		for (int i = 1; i &lt;= n; i++)
		{
			scanf(&quot;%d&quot;, &amp;a[i]);
			s[i] = P(a[i] + s[i - 1].first, i);
		}
		sort(s, s + n + 1);//保证0在负数后面，即开始就出现正数，负数的话会一直更新en++
		while (k--)
		{
			scanf(&quot;%d&quot;, &amp;t);
			int st = 0, en = 1, minv = INF,l=1,r=n,ans=s[1].first;
			while (en &lt;= n)
			{
				int sum = s[en].first - s[st].first;
				if (abs(sum - t) &lt; minv){
					minv = abs(sum - t);
					l = s[st].second, r = s[en].second;
					ans = sum;
				}
				if (sum == t)
					break;
				else if (sum &lt; t){
					en++;
				}
				else{
					st++;
				}
				if (st == en) en++;
			}
			if (l&gt;r) swap(l, r);
			printf(&quot;%d %d %d\n&quot;, ans, l+1, r);
		}
		
	}
	return 0;
}
</code></pre>
<blockquote>
<p><a href="http://poj.org/problem?id=2739">poj2739</a>
<a href="http://poj.org/problem?id=2100">poj2100</a>
找到某一个区间使得区间内的数的和/平方和等于某一给定值k</p>
</blockquote>
<pre><code>
//poj2739
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include&lt;iostream&gt;
#define INF 0x3f3f3f3f
#define LL long long
#define N 10100
using namespace std;
int prime[N], tot;
bool vis[N];
int n;
void get_prime(int n)
{
	memset(vis, true, sizeof(vis));
	for (int i = 2; i &lt;= n; i++)
	{
		if (vis[i]){
			prime[++tot] = i;
			for (int j = i + i; j &lt;= n; j += i){
				vis[j] = false;
			}
		}
	}
}
int main()
{
	get_prime(10090);
	while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
	{
		int st = 1, en = 1,sum=0,ans=0;
		while (1)
		{
			while (sum &lt; n&amp;&amp;prime[en] &lt;= n) sum += prime[en++];
			if (sum == n) ans++;
			if (sum&lt;n) break;
			sum -= prime[st++];
		}
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}

</code></pre>
<pre><code>
//poj2100
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#define INF 0x3f3f3f3f
typedef long long ll;
#define N 10100
using namespace std;
typedef pair&lt;ll, ll&gt; P;
vector&lt;P&gt; ans;
ll n;
int main()
{
	while (cin &gt;&gt; n)
	{
		ans.clear();
		ll st = 1, en = 1;
		ll sum = 0;
		while (1)
		{
			while (sum &lt; n&amp;&amp;en*en &lt;= n)
				sum += en*en,en++;
			if (sum == n){
				ans.push_back(P(st, en));
			}
			if (sum &lt; n)
				break;
			sum -= st*st;
			st++;
		}
		printf(&quot;%d\n&quot;, ans.size());
		for (int i = 0; i &lt; ans.size(); i++)
		{
			P t = ans[i];
			printf(&quot;%lld&quot;, t.second - t.first);
			for (ll j = t.first; j &lt; t.second; j++)
				printf(&quot; %lld&quot;, j);
			printf(&quot;\n&quot;);
		}
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforce 1163 B Cat Party]]></title>
        <id>https://www.akwing.cn/post/codeforce-1163-b-cat-party</id>
        <link href="https://www.akwing.cn/post/codeforce-1163-b-cat-party">
        </link>
        <updated>2019-05-10T05:55:28.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="好题">好题</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="好题">好题</h1>
<!-- more -->
<blockquote>
<p>题目链接 <a href="https://codeforces.com/contest/1163/problem/B2">Cat Party</a></p>
</blockquote>
<blockquote>
<p>题目大致意思 题目会给出n天，每天都会有一个颜色<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，找出最大的<code>x</code>使<strong>删除前x天中的某一天</strong>，使得剩下的x-1天出现过的颜色个数相同</p>
</blockquote>
<p>如果<code>x</code>满足以下四个条件之一，那么这个<code>x</code>就是合法的。</p>
<ul>
<li>前<code>x</code>天内只出现过一种颜色</li>
<li>前<code>x</code>天内出现过x种颜色，每种颜色的个数为1</li>
<li>前<code>x</code>天内只有一种颜色出现过一次，既个数为1，其他若干种颜色的个数相同。</li>
<li>前<code>x</code>天内出现个数最多的颜色只有一种，其他种类的颜色个数相同，且这个最多个数的颜色比这些颜色个数多1</li>
</ul>
<p>可以发现，我们每次判断<code>x</code>是否合法几乎只与颜色个数为1的和颜色个数最多的那些颜色有关。所以我们就可用数组来保存这些颜色的信息，然后<code>O(1)</code>判断，总复杂度为<code>O(n)</code>.
具体看代码实现.</p>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;
int n, x,ans, mx, cnt[N], f[N];
//f[i] 颜色为i的个数
//cnt[i]表示个数为i的颜色的种类
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++)
	{
		scanf(&quot;%d&quot;, &amp;x);
		cnt[f[x]]--;//x要加1，所以原来种类的要减去1
		f[x]++;
		cnt[f[x]]++;
		mx = max(mx, f[x]);//保存出现最多的颜色的个数
		//每种颜色的个数都是1
		if (cnt[1] == i) ans = i;
		//只有一种颜色，i个
		else if (cnt[i] == 1) ans = i;
		//只有一种颜色个数是一，其他若干种颜色个数相同
		else if (cnt[1] == 1 &amp;&amp; cnt[mx] * mx == i - 1) ans = i;
		//个数最多的颜色的个数为mx,它的种类必须为1，并且比其他种类的颜色多1个，且其他种类的颜色的个数必须相同
		else if (cnt[mx - 1] * (mx - 1) == i - mx&amp;&amp;cnt[mx] == 1) ans = i;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Gym 101147 J-Whistle's New Car]]></title>
        <id>https://www.akwing.cn/post/codeforces-gym-101147-j-whistles-new-car</id>
        <link href="https://www.akwing.cn/post/codeforces-gym-101147-j-whistles-new-car">
        </link>
        <updated>2019-05-06T10:46:57.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="dfs">DFS</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="dfs">DFS</h1>
<!-- more -->
<blockquote>
<p>题目链接<a href="https://codeforces.com/gym/101147/problem/J"> Whistle's New Car</a></p>
</blockquote>
<p>题目的意思是给定 <code>n</code> 个城市编号 <code>1-n</code> ,每个城市都有一个权值    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
,两个城市间的距离  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_ {ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 这些城市的结构是一颗以 <code>1</code> 为根节点的树，输出每个城市<code>i</code>的<code>attractiveness</code>   ，每个节点 <code>attractiveness</code> 是满足以下条件的城市的个数</p>
<ol>
<li><code>j</code> 是 <code>i</code> 的子树。</li>
<li>在城市<code>j</code>加满 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">X_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的油后不再加油能到达 i 城市。</li>
</ol>
<p>主要思路：从根节点<code>1</code>出发DFS整棵树，我们用<code>s[i]</code>表示根节点到第<code>i</code>个节点的路径长度之和,(第 <strong><code>i</code></strong> 个节点貌似不恰当，可以理解为第 <strong><code>i</code></strong> 层).<code>num</code> 数组保存了我们 <code>dfs</code> 过程中之前所经过的城市(后面有用)。对于当前城市<code>i</code>它只能往上走，我们需要判断它能往上走到哪里,我们可以发现,对于在<code>i</code>之前的城市<code>j</code>如果满足  <strong><code>s[j]+x[i]&gt;=s[i]</code></strong> ，那么我们就可以从城市<code>i</code>走到城市<code>j</code>，因此我们需要找到最小的<code>j</code>，满足 <strong><code>s[j]&gt;=s[i]-x[i]</code></strong>  ,对于这个我们可以二分查找<code>s</code>数组，找到满足条件的最小的<code>j</code>,<code>j</code>城市满足条件，<code>j</code>到<code>i</code>路上所有的城市节点都满足条件(不包括i)，因此我们把<code>j,j+1....i-1</code>这些城市答案都加<code>1</code>，对于闭区间<code>[j~i-1]</code> 的值加上<code>1</code>，可以类似于差分来处理，<code>cnt[i-1]++</code>,<code>cnt[j-1]--</code>.这里让<code>cnt[j-1]--</code>，是为消除城市节点<code>j</code>之前的城市的影响，因为我们每次统计答案是<code>cnt[u] += cnt[v]</code> (<code>v</code>是<code>u</code>的孩子),对<code>[j~i-1]</code>之间的城市我们这样操作后它们的答案都会加<code>1</code>，但<code>j</code>之前的城市我们不能让它答案加<code>1</code>，因此我们<code>cnt[j-1]--</code>来消除这个影响。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
#define lowbit(x) (x&amp;(-x))
typedef long long ll;
const int N = 5e5 + 10;
int n;
ll a[N],s[N];
typedef pair&lt;int, ll&gt; P;
vector&lt;P&gt; p[N];
int cnt[N],num[N];
int ret;
void dfs(int u, int pre)
{
	for (auto E : p[u])
	{
		int v = E.first;
		ll w = E.second;
		if (v == pre) continue;
		s[ret] = s[ret - 1] + w;
		num[ret] = v; //路径上第ret城市为v
		int pos = lower_bound(s, s + ret + 1, s[ret] - a[v])-s;
		if (pos &lt; ret)//如果能到达父结点城市
		{
			cnt[u]++;
			if (pos) cnt[num[pos - 1]]--;//这个一定要减，不然后面节点的数加到父节点的时候，父节点就多加了
		}
		ret++;
		dfs(v, u);
		ret--;
		cnt[u] += cnt[v];
	}
}
int main()
{
	freopen(&quot;car.in&quot;, &quot;r&quot;, stdin);
	int T;
	scanf(&quot;%d&quot;, &amp;T);
	while (T--)
	{
		ret = 1;
		memset(cnt, 0, sizeof(cnt));
		scanf(&quot;%d&quot;, &amp;n);
		for (int i = 1; i &lt;= n; i++)
		{
			scanf(&quot;%lld&quot;, &amp;a[i]);
			p[i].clear();
		}
		for (int i = 1; i &lt; n; i++)
		{
			int u,v;
			ll w;
			scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;w);
			p[u].push_back(P(v, w));
			p[v].push_back(P(u, w));
		}
		ret = 1;
		num[0] = 1;
		s[0] = 0;
		dfs(1, -1);
		for (int i = 1; i &lt;= n; i++)
			printf(&quot;%d%c&quot;, cnt[i], i == n ? '\n' : ' ');
	}
	fclose(stdin);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforce Gym 101086 D - Secure but True]]></title>
        <id>https://www.akwing.cn/post/codeforce-gym-101086-d-secure-but-true</id>
        <link href="https://www.akwing.cn/post/codeforce-gym-101086-d-secure-but-true">
        </link>
        <updated>2019-05-05T10:03:08.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="思维模拟">思维+模拟</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="思维模拟">思维+模拟</h1>
<!-- more -->
<blockquote>
<p>题目链接 <a href="https://codeforces.com/gym/101086/problem/D">Secure but True </a></p>
</blockquote>
<blockquote>
<p>题目的大致意思是给出11个字符 <code>{A, H, I, M, O, T, U, V, W, X, Y},</code> ，这些字符可以任意结合组成字符串，这些字符串排序首先按照它们的长度排序，长度相同按照字典序排序，然后题目给你T个询问，每个询问给一个整数 <strong><code>k</code></strong> ，一个字符串 <strong><code>s</code></strong>   ，然后询问字符串s后的第k的字符串是什么。</p>
</blockquote>
<p>首先这11个字符可以组成无数个字符串，而k的范围又是1e9,所以不可能直接做。首先由11个字符先按照长度再按照字典序排可以想到10进制数，<strong><code>0-9 10-19 20-29</code></strong>  ,这 <strong><code>10</code></strong> 个数不正是先按照长度，再按照字典序来排的吗。于是这题也就和 <strong><code>11</code></strong> 进制相关，于是我和我队友想到了如下思路，将k转化为11进制，再将字符串s转化为11进制，<code>A-Y</code> 分别代表 <code>1-11</code>，然后相加，得到的结果再按照对应字符输出。
我们按照这个思路写了一下，然后交上去WA了，后来我们发现将k转化为11进制后会出现0，对于0我们无法处理，因为我们是把 <code>A-Y</code> 分别代表 <code>1-11</code> 来处理的，出现0我们就无法处理，于是我们就改了好长时间代码，还是没能正常处理0. 我们把Y当成0处理也不行，最后这题没能A掉。
比赛过后，我请教了一位大佬，就是用11进制做，A-Y仍分别代表1-11。然后模拟两个11进制相加。所以我们用短除法把k转为11进制这个方法错了。要用其他方法把k转化为11进制,并且不出现0，既每一位最低是1。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2e5 + 100;
string ss = &quot;AAHIMOTUVWXY&quot;;
typedef long long ll;
int to[128], k;
char s[N];
int a[N];
int b[N];
ll Pow[N];
void dfs(int x, int val)
{
	if (x&lt;0) return;
	for (int i = 1; i &lt;= 11; i++)
	{
		if (val &gt;= Pow[x]){
			val -= Pow[x];
		}
		else{
			b[x] = i;
			dfs(x - 1, val);
			break;
		}
	}
}
void Ac()
{
	memset(a, 0, sizeof(a));
	memset(b, 0, sizeof(b));
	scanf(&quot;%d%s&quot;, &amp;k, s);
	int len1 = strlen(s);
	for (int i = 0; i &lt; len1; i++)
		a[i] = to[s[i]];
	reverse(a, a + len1);
	int len2 = 0;
	//不能让0出现，这个处理保证了每一位最少是1 (与平时短除法转化不一样)
	for (int i = 0; i &lt;= 12; i++)
	{
		if (k &lt; Pow[i]){
			len2 = i;
			break;
		}
		else{
			//b[i]=1;
			k -= Pow[i];
		}
	}
	//这个dfs模拟转化11进制
	dfs(len2 - 1, k);
	//for (int i = 0; i &lt; len2; i++)
		//cout &lt;&lt; b[i] &lt;&lt; ' ';
	//cout &lt;&lt; endl;
	len1 = max(len1, len2);
	for (int i = 0; i &lt; len1; i++)
	{
		a[i] += b[i];
		while (a[i]&gt;11) a[i] -= 11, b[i + 1]++;
	}
	if (b[len1])  a[len1] += b[len1],len1++;
	for (int i = len1 - 1; i &gt;= 0; i--)
		putchar(ss[a[i]]);
	puts(&quot;&quot;);
}

int main(){
	int T;
	scanf(&quot;%d&quot;, &amp;T);
	Pow[0] = 1;
	for (int i = 1; i &lt;= 12; ++i)
		Pow[i] = Pow[i - 1] * 11;
	for (int i = 1; i &lt;= 11; i++)
		to[ss[i]] = i;
	while (T--)
		Ac();
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[POJ 2796 Feel Good]]></title>
        <id>https://www.akwing.cn/post/poj-2796-feel-good</id>
        <link href="https://www.akwing.cn/post/poj-2796-feel-good">
        </link>
        <updated>2019-05-04T11:36:58.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="单调栈">单调栈</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="单调栈">单调栈</h1>
<!-- more -->
<p><a href="http://poj.org/problem?id=2796">POJ 2796</a></p>
<p>题目的大致意思是，给你n个数，我们需要计算一个值，这个值是这个序列中的一段连续的子序列里的最小值乘于这段连续子序列的和，我们要使得求得的这个值最大，比如样例 <code>6 3 1 6 4 5 2</code>，我们选择<code>6 4 5</code>这段连续的子序列，值为<code>4*(6+4+5)=60</code>
首先对于每个数<code>a[i]</code>，我们想让他最大可能的往左右扩展，知道这个数往左和往右最大的扩展的坐标<code>l,r</code>,利用前缀和我们就求得了这个值<code>a[i]*(s[r]-s[l-1])</code>，所以这题在于我们怎么去求一个数往左右扩展的最大位置.
我们先以往右扩展为例，用 <strong><code>R[i]</code></strong>  表示 <strong><code>i</code></strong> 往右扩展的最大位置。我们建立一个单调栈，这个单调栈是单调递减的，即栈顶到栈底递减，用数组表示即是从左到右递增。我们扫描这个序列。</p>
<ul>
<li>如果当前这个数比栈顶大或者等于，我们直接入栈。</li>
<li>如果当前这个数比栈顶小，我们就从栈中弹出数，直到这个数比栈顶大，那怎么记录往右扩展的最大位置呢，我们在把数从栈中弹出的过程中，弹出的数一定比当前要入栈的数大，因此他一定不是最小的数，对后面没有作用，因此弹出的数最大扩展位置就是当前这个数的位置i再减去1,即<code>i-1</code>。
我们用<code>pos</code>数组记录一下栈中数所在的位置，同时<code>a[n+1]</code>设为<code>-1</code>，保证最后栈中元素都可以被弹出。
向左扩展也是一样道理。</li>
</ul>
<pre><code>#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;
int a[N], n, L[N], R[N], s[N], tot, pos[N];
ll sum[N];
pair&lt;int, int&gt; ans;
int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++){
        scanf(&quot;%d&quot;, &amp;a[i]);
        sum[i] = sum[i - 1] + 1LL*a[i];
        L[i] = R[i] = i;
    }
    a[n + 1] = -1;
    for (int i = 1; i &lt;= n+1; i++)
    {
        if (a[i] &gt;= s[tot])
            s[++tot] = a[i],pos[tot]=i;
        else{
            while (tot&amp;&amp;a[i] &lt; s[tot]){
                R[pos[tot]] = i - 1;
                tot--;
            }
            s[++tot] = a[i],pos[tot]=i;
        }
    }
    a[0] = -1,tot=0;
    for (int i = n; i &gt;= 0; i--){
        if (a[i] &gt;= s[tot]){
            s[++tot] = a[i],pos[tot]=i;
        }
        else{
            while (tot&amp;&amp; a[i] &lt; s[tot]){
                L[pos[tot]] = i+1;
                tot--;
            }
            s[++tot] = a[i], pos[tot] = i;
        }
    }
    ll max_val= -1;
    for (int i = 1; i &lt;= n; i++){
        if (a[i]*(sum[R[i]] - sum[L[i] - 1]) &gt; max_val)
        {
            max_val = a[i] * (sum[R[i]] - sum[L[i] - 1]);
            ans.first = L[i];
            ans.second = R[i];
        }
    }
    cout &lt;&lt; max_val &lt;&lt; endl;
    cout &lt;&lt; ans.first &lt;&lt; &quot; &quot; &lt;&lt; ans.second &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>