<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://TheGayhub.github.io</id>
    <title>Guapi</title>
    <updated>2019-06-19T05:59:34.447Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://TheGayhub.github.io"/>
    <link rel="self" href="https://TheGayhub.github.io/atom.xml"/>
    <subtitle>惟世之繁华如故,斟酌岁月如初</subtitle>
    <logo>https://TheGayhub.github.io/images/avatar.png</logo>
    <icon>https://TheGayhub.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Guapi</rights>
    <entry>
        <title type="html"><![CDATA[E. Minimal Segment Cover]]></title>
        <id>https://TheGayhub.github.io/post/e-minimal-segment-cover</id>
        <link href="https://TheGayhub.github.io/post/e-minimal-segment-cover">
        </link>
        <updated>2019-06-15T07:24:56.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1175/problem/E">Minimal Segment Cover</a></p>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define x first
#define y second
#define forn(i, n) for(int i = 0; i &lt; int(n); i++) 

const int N = 500 * 1000 + 13;
const int LOGN = 18;

int n, m;
pair&lt;int, int&gt; a[N], q[N];

int nxt[N];
int up[LOGN][N];

int main(){
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	forn(i, n)
		scanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].y);
	forn(i, m)
		scanf(&quot;%d%d&quot;, &amp;q[i].x, &amp;q[i].y);
	
	sort(a, a + n);
	
	int lst = 0;
	pair&lt;int, int&gt; mx(0, -1);
	forn(i, N){
		while (lst &lt; n &amp;&amp; a[lst].x == i){
			mx = max(mx, make_pair(a[lst].y, lst));
			++lst;
		}
		nxt[i] = (mx.x &lt;= i ? -1 : mx.y);
	}
	
	forn(i, n)
		up[0][i] = nxt[a[i].y];
	for (int j = 1; j &lt; LOGN; ++j) forn(i, n){
		if (up[j - 1][i] == -1)
			up[j][i] = -1;
		else
			up[j][i] = up[j - 1][up[j - 1][i]];
	}
	
	forn(i, m){
		int x = nxt[q[i].x];
		
		if (x == -1){
		puts(&quot;-1&quot;);
		continue;
		}
		
		int res = 0;
		for (int j = LOGN - 1; j &gt;= 0; --j){
			int y = up[j][x];
			if (y == -1)
				continue;
			if (a[y].y &lt; q[i].y){
				res += (1 &lt;&lt; j);
				x = y;
			}
		}
		
		if (a[x].y &gt;= q[i].y)
			printf(&quot;%d\n&quot;, res);
		else if (up[0][x] == -1)
			puts(&quot;-1&quot;);
		else
			printf(&quot;%d\n&quot;, res + 1);
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HDU 5710 Digit-Sum]]></title>
        <id>https://TheGayhub.github.io/post/hdu-5710-digit-sum</id>
        <link href="https://TheGayhub.github.io/post/hdu-5710-digit-sum">
        </link>
        <updated>2019-06-11T05:37:36.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="构造">构造</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="构造">构造</h1>
<!-- more -->
<p><img src="https://TheGayhub.github.io/post-images/1560233194009.png" alt=""></p>
<p>很容易发现，当 2 * n 每进1位的时候，与 2 * S(n)的差就会少去9，这也可以推出来，因为满10进1，每进1位就会少10，得到1，所以每进1位就会少9.所以当n的数位上出现[5-9]时，乘于2就会少9，假设n的所有位上一共有L个[5-9]的数
我们可以得到 <code>S(2n)=2*S(n)-L*9</code>  再由 <code>a×S(n)=b×S(2n)</code> ,所以 <code>L/S(n)=(2*b-a)/(9*b)</code> 。(注意要上下同除gcd)
所以我们可以让 <code>L=2*b-a,S(n)=9*b</code> ,那如何贪心构造出最小的n呢？
我们先让n中的L位数全为5，即  xxx555(L个5)，S(n)-5 * L,然后剩下的S(n)再从末尾不断的加上去。
当<code>L&lt;0||5 * L&gt;S(n)</code> 的时候就是无解。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 2e5 + 10;
int a, b;
int gcd(int a, int b)
{
    if (b == 0) return a;
    return gcd(b, a%b);
}
int ans[N];
int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        int d = gcd(a, b);
        a /= d, b /= d;
        int l = 2 * b - a, sn = 9 * b;
        if (l&lt;0 || l * 5&gt;sn){
            puts(&quot;0&quot;);
            continue;
        }
        d = gcd(l, sn);
        l /= d, sn /= d;
        int tot = 0;
        sn -= 5 * l;
        for (int i = 0; i &lt; l; i++)
        {
            int tmp = min(4, sn);
            ans[tot++] = 5 + tmp;
            sn -= tmp;
        }
        while (sn)
        {
            int tmp = min(4, sn);
            ans[tot++] = tmp;
            sn -= tmp;
        }
        for (int i = tot - 1; i &gt;= 0; i--)
            cout &lt;&lt; ans[i];
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZOJ 2112 Dynamic Rankings ]]></title>
        <id>https://TheGayhub.github.io/post/zoj-2112-dynamic-rankings</id>
        <link href="https://TheGayhub.github.io/post/zoj-2112-dynamic-rankings">
        </link>
        <updated>2019-06-10T06:08:02.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="树状数组套主席树">树状数组套主席树</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="树状数组套主席树">树状数组套主席树</h1>
<!-- more -->
<p>之前学了主席树，解决了静态区间第k大，想着顺便学习一下如何求解动态区间第k大，奈何太菜，看了一晚上未能很好的理解，主要就是询问的时候卡住了我。第二天终于理解了。
这里给出两种方法</p>
<ul>
<li>方法1</li>
</ul>
<p>前缀和建树(和静态主席树一样)，树状数组更新，<strong>树状数组只保存更新带来的影响</strong>，每次查询左孩子区间sum的时候需要同时查询 <strong>(原来的值+树状数组的影响)</strong></p>
<ul>
<li>方法2</li>
</ul>
<p>类似树状数组的方式建树，<code>T[i]</code> 只保存区间<code>[i-lowbit(i)+1,i]</code>内的个数， 更新和查询都类似树状数组,这里树状数组直接保存了更新后的结果，<strong>因此询问时只需查询树状数组</strong>。</p>
<p>方法1的代码在洛谷和ZOJ都能过，方法2就只能过洛谷，ZOJ一直SF。</p>
<blockquote>
<p>方法1</p>
</blockquote>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define lowbit(x) (x&amp;(-x))
typedef long long ll;
const int N = 6e4 + 10;
const int M = 2500000;
int a[N], b[N * 2], tot, n, m, q, numx, numy;
struct query{
	int op, l, r, v;
}p[10005];
struct tree{
	int lc, rc, cnt;
}T[N * 32];
int root[N];
int ux[50], uy[50];
int S[N];
void build(int &amp;rt, int l, int r)
{
	rt = ++tot;
	T[rt].cnt = 0;
	T[rt].lc = T[rt].rc = 0;
	if (l == r) return;
	int mid = (l + r) &gt;&gt; 1;
	build(T[rt].lc, l, mid);
	build(T[rt].rc, mid + 1, r);
}
void update(int &amp;cur, int pre, int l, int r, int pos, int val)
{
	cur = ++tot;
	T[cur] = T[pre];
	T[cur].cnt += val;
	if (l == r) return;
	int mid = (l + r) &gt;&gt; 1;
	if (pos &lt;= mid) update(T[cur].lc, T[pre].lc, l, mid, pos, val);
	else update(T[cur].rc, T[pre].rc, mid + 1, r, pos, val);
}
void add(int pos, int val)
{
	int npos = lower_bound(b + 1, b + m + 1, a[pos]) - b;
	for (; pos &lt;= n; pos += lowbit(pos))
		update(S[pos], S[pos], 1, m, npos, val);
}
int query(int l, int r, int x, int y, int k)
{
	if (l == r) return l;
	int mid = (l + r) &gt;&gt; 1;
	int sum = 0;
	for (int j = 0; j &lt; numx; j++) sum -= T[T[ux[j]].lc].cnt;
	for (int j = 0; j &lt; numy; j++) sum += T[T[uy[j]].lc].cnt;
	sum += T[T[y].lc].cnt - T[T[x].lc].cnt;
	if (k&gt;sum)
	{
		for (int j = 0; j &lt; numx; j++)
			ux[j] = T[ux[j]].rc;
		for (int j = 0; j &lt; numy; j++)
			uy[j] = T[uy[j]].rc;
		return query(mid + 1, r, T[x].rc, T[y].rc, k - sum);
	}
	else
	{
		for (int j = 0; j &lt; numx; j++)
			ux[j] = T[ux[j]].lc;
		for (int j = 0; j &lt; numy; j++)
			uy[j] = T[uy[j]].lc;
		return query(l, mid, T[x].lc, T[y].lc, k );
	}
	
	
}
int main()
{
	int t;
	scanf(&quot;%d&quot;, &amp;t);
	while (t--)
	{
		tot = 0;
		m = 0;
		scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
		for (int i = 1; i &lt;= n; i++)
		{
			scanf(&quot;%d&quot;, &amp;a[i]);
			b[++m] = a[i];
		}
		for (int i = 1; i &lt;= q; i++)
		{
			char op[5];
			scanf(&quot;%s&quot;, op);
			if (op[0] == 'Q')
			{
				scanf(&quot;%d%d%d&quot;, &amp;p[i].l, &amp;p[i].r, &amp;p[i].v);
				p[i].op = 1;
			}
			else
			{
				scanf(&quot;%d%d&quot;, &amp;p[i].l, &amp;p[i].r);
				b[++m] = p[i].r;
				p[i].op = 2;
			}
		}
		sort(b + 1, b + m + 1);
		m = unique(b + 1, b + m + 1) - b - 1;
		build(root[0], 1, m);
		for (int i = 1; i &lt;= n; i++)
		{
			int pos = lower_bound(b + 1, b + m + 1, a[i]) - b;
			update(root[i], root[i - 1], 1, m, pos, 1);
		}
		for (int i = 0; i &lt;= n; i++)
			S[i] = root[0];
		for (int i = 1; i &lt;= q; i++)
		{
			if (p[i].op == 1)
			{
				numx = 0, numy = 0;
				for (int j = p[i].l - 1; j &gt; 0; j -= lowbit(j)) ux[numx++] = S[j];
				for (int j = p[i].r; j &gt; 0; j -= lowbit(j)) uy[numy++] = S[j];
				int ans = query(1, m, root[p[i].l - 1], root[p[i].r], p[i].v);
				printf(&quot;%d\n&quot;, b[ans]);
			}
			else
			{
				add(p[i].l, -1);
				a[p[i].l] = p[i].r;
				add(p[i].l, 1);
			}
		}

	}

	return 0;
}

</code></pre>
<blockquote>
<p>方法2(顺便来个非递归查询和更新)</p>
</blockquote>
<pre><code>// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define lowbit(x) (x&amp;(-x))
typedef long long ll;
const int N = 1e5+ 10;
const int M = 2500000;
int a[N], b[N*2], tot, n, m, q,numx,numy;
struct query{
    int op, l, r, v;
}p[100005];
struct tree{
    int lc, rc, cnt;
}T[N&lt;&lt;9];
int root[N];
int ux[50], uy[50];
void build(int &amp;rt,int l,int r)
{
    rt = ++tot;
    T[rt].cnt = 0;
    T[rt].lc = T[rt].rc = 0;
    if (l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    build(T[rt].lc, l, mid);
    build(T[rt].rc, mid + 1, r);
}
void update(int &amp;cur, int pre,int l, int r,int pos,int val)
{
    cur = ++tot;
    T[cur] = T[pre];
    T[cur].cnt += val;
    int tmp = cur;
    while (l &lt; r)
    {
        int mid = (l + r) &gt;&gt; 1;
        if (pos &lt;= mid)
        {
            T[tmp].lc = ++tot;
            T[tmp].rc = T[pre].rc;
            pre = T[pre].lc;
            tmp = T[tmp].lc;
            r = mid;
        }
        else
        {
            T[tmp].rc = ++tot;
            T[tmp].lc = T[pre].lc;
            pre = T[pre].rc;
            tmp = T[tmp].rc;
            l = mid + 1;
        }
        T[tmp].cnt = T[pre].cnt + val;
    }
    return;
}
void add(int pos, int val)
{
    int npos = lower_bound(b + 1, b + m + 1, a[pos]) - b;
    for (; pos &lt;= n; pos += lowbit(pos))
        update(root[pos], root[pos], 1, m, npos, val);
}
int query(int l,int r,int k)
{
    while (l &lt; r)
    {
        int mid = (l + r) &gt;&gt; 1;
        int sum = 0;
        for (int j = 0; j &lt; numx; j++) sum -= T[T[ux[j]].lc].cnt;
        for (int j = 0; j &lt; numy; j++) sum += T[T[uy[j]].lc].cnt;
        if (k&gt;sum)
        {
            k -= sum;
            for (int j = 0; j &lt; numx; j++)
                ux[j] = T[ux[j]].rc;
            for (int j = 0; j &lt; numy; j++)
                uy[j] = T[uy[j]].rc;
            l = mid + 1;
        }
        else
        {
            for (int j = 0; j &lt; numx; j++)
                ux[j] = T[ux[j]].lc;
            for (int j = 0; j &lt; numy; j++)
                uy[j] = T[uy[j]].lc;
            r = mid;
        }
    }

    return l;
}
int main()
{
    tot = 0;
    m = 0;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
    for (int i = 1; i &lt;= n; i++)
    {
        scanf(&quot;%d&quot;, &amp;a[i]);
        b[++m] = a[i];
    }
    for (int i = 1; i &lt;= q; i++)
    {
        char op[5];
        scanf(&quot;%s&quot;, op);
        if (op[0] == 'Q')
        {
            scanf(&quot;%d%d%d&quot;, &amp;p[i].l, &amp;p[i].r, &amp;p[i].v);
            p[i].op = 1;
        }
        else
        {
            scanf(&quot;%d%d&quot;, &amp;p[i].l, &amp;p[i].r);
            b[++m] = p[i].r;
            p[i].op = 2;
        }
    }
    sort(b + 1, b + m + 1);
    m = unique(b + 1, b + m + 1) - b - 1;
    for (int i = 1; i &lt;= n; i++)
        add(i, 1);
    for (int i = 1; i &lt;= q; i++)
    {
        if (p[i].op == 1)
        {
            numx = 0, numy = 0;
            for (int j = p[i].l-1; j &gt; 0; j -= lowbit(j)) ux[numx++] = root[j];
            for (int j = p[i].r; j &gt; 0; j -= lowbit(j)) uy[numy++] = root[j];
            int ans = query(1, m, p[i].v);
            printf(&quot;%d\n&quot;, b[ans]);
        }
        else
        {
            add(p[i].l, -1);
            a[p[i].l] = p[i].r;
            add(p[i].l, 1);
        }
    }

    return 0;
}

			
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[尺取法小合集]]></title>
        <id>https://TheGayhub.github.io/post/chi-qu-fa-xiao-he-ji</id>
        <link href="https://TheGayhub.github.io/post/chi-qu-fa-xiao-he-ji">
        </link>
        <updated>2019-05-10T08:34:30.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="尺取法">尺取法</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="尺取法">尺取法</h1>
<!-- more -->
<h3 id="尺取法顾名思义像尺子一样取一段借用挑战书上面的话说尺取法通常是对数组保存一对下标即所选取的区间的左右端点然后根据实际情况不断地推进区间左右端点以得出答案-之所以需要掌握这个技巧是因为尺取法比直接暴力枚举区间效率高很多尤其是数据量大的">尺取法：顾名思义，像尺子一样取一段，借用挑战书上面的话说，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。之所以需要掌握这个技巧，是因为尺取法比直接暴力枚举区间效率高很多，尤其是数据量大的</h3>
<h3 id="时候所以尺取法是一种高效的枚举区间的方法一般用于求取有一定限制的区间个数或最短的区间等等-当然任何技巧都存在其不足的地方有些情况下尺取法不可行无法得出正确答案">时候，所以尺取法是一种高效的枚举区间的方法，一般用于求取有一定限制的区间个数或最短的区间等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案。</h3>
<h3 id="使用尺取法时应清楚以下四点">使用尺取法时应清楚以下四点：</h3>
<h3 id="1-什么情况下能使用尺取法-2-何时推进区间的端点-3-如何推进区间的端点-3-何时结束区间的枚举">1、  什么情况下能使用尺取法?  2、何时推进区间的端点？ 3、如何推进区间的端点？ 3、何时结束区间的枚举？</h3>
<h3 id="尺取法通常适用于选取区间有一定规律或者说所选取的区间有一定的变化趋势的情况通俗地说在对所选取区间进行判断之后我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间如果已经判断了目前所选取的区间但却无法确定所要求解的区间如何进一步得到根据其端点得到那么尺取法便是不可行的-首先明确题目所需要求解的量之后区间左右端点一般从最整个数组的起点开始之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案">尺取法通常适用于选取区间有一定规律，或者说所选取的区间有一定的变化趋势的情况，通俗地说，在对所选取区间进行判断之后，我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间，如果已经判断了目前所选取的区间，但却无法确定所要求解的区间如何进一步得到根据其端点得到，那么尺取法便是不可行的。首先，明确题目所需要求解的量之后，区间左右端点一般从最整个数组的起点开始，之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案。</h3>
<h3 id="总结尺取法的模型便是这样根据区间的特征交替推进左右端点求解问题其高效的原因在于避免了大量的无效枚举其区间枚举都是根据区间特征有方向的枚举如果胡乱使用尺取法的话会使得枚举量减少因而很大可能会错误所以关键的一步是进行问题的分析">总结：尺取法的模型便是这样：根据区间的特征交替推进左右端点求解问题，其高效的原因在于避免了大量的无效枚举，其区间枚举都是根据区间特征有方向的枚举，如果胡乱使用尺取法的话会使得枚举量减少，因而很大可能会错误，所以关键的一步是进行问题的分析</h3>
<p><a href="https://blog.csdn.net/lxt_lucia/article/details/81091597">来自</a></p>
<!-- more -->
<blockquote>
<p><a href="http://poj.org/problem?id=3061">POJ 3061 Subsequence</a></p>
</blockquote>
<pre><code>
#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 1e5 + 10;
int n, s,a[N];
int main(){
	int t;
	cin &gt;&gt; t;
	while (t--)
	{
		scanf(&quot;%d%d&quot;, &amp;n,&amp;s);
		for (int i = 1; i &lt;= n; i++)
			scanf(&quot;%d&quot;, &amp;a[i]);
		int st = 1, en = 1;
		int tot = 0;
		int ans = n+10;
		while (1)
		{
			while (en &lt;= n&amp;&amp;tot &lt; s)
				tot += a[en++];
			if (tot &lt; s)
				break;
			ans = min(ans, en - st);
			tot -= a[st++];
		}
		if (ans == n + 10) printf(&quot;0\n&quot;);
		else 
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}
</code></pre>
<blockquote>
<p><a href="http://poj.org/problem?id=3320">POJ 3320 Jessica's Reading Problem</a>
求最小的页数覆盖所有知识点</p>
</blockquote>
<pre><code>
#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;
const int N = 1e6 + 10;
int n,a[N];
set&lt;int&gt; s;
map&lt;int, int&gt; cnt;
int main(){
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++)
		scanf(&quot;%d&quot;, &amp;a[i]),s.insert(a[i]);
	int sum = s.size();
	int st = 1, en = 1, tot = 0;
	int ans = n;
	while (1)
	{
		while (en &lt;= n&amp;&amp;tot &lt; sum){
			if (cnt[a[en]] == 0){
				tot++;
			}
			cnt[a[en++]]++;
		}
		if (tot &lt; sum) break;
		ans = min(ans, en - st);
		--cnt[a[st]];
		if (cnt[a[st++]] == 0) tot--;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
<blockquote>
<p><a href="http://poj.org/problem?id=2566">POJ 2566 Bound Found</a>
给定一个数组和一个值t，求一个子区间使得其和的绝对值与t的差值最小，如果存在多个，任意解都可行。</p>
</blockquote>
<pre><code>
#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;
const int N = 1e5 + 10;
const int INF = 1e9 + 10;
int n,k,t,a[N];
typedef pair&lt;int, int&gt; P;
P s[N];
int main()
{
	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) &amp;&amp; (n || k))
	{
		s[0] = P(0, 0);
		for (int i = 1; i &lt;= n; i++)
		{
			scanf(&quot;%d&quot;, &amp;a[i]);
			s[i] = P(a[i] + s[i - 1].first, i);
		}
		sort(s, s + n + 1);//保证0在负数后面，即开始就出现正数，负数的话会一直更新en++
		while (k--)
		{
			scanf(&quot;%d&quot;, &amp;t);
			int st = 0, en = 1, minv = INF,l=1,r=n,ans=s[1].first;
			while (en &lt;= n)
			{
				int sum = s[en].first - s[st].first;
				if (abs(sum - t) &lt; minv){
					minv = abs(sum - t);
					l = s[st].second, r = s[en].second;
					ans = sum;
				}
				if (sum == t)
					break;
				else if (sum &lt; t){
					en++;
				}
				else{
					st++;
				}
				if (st == en) en++;
			}
			if (l&gt;r) swap(l, r);
			printf(&quot;%d %d %d\n&quot;, ans, l+1, r);
		}
		
	}
	return 0;
}
</code></pre>
<blockquote>
<p><a href="http://poj.org/problem?id=2739">poj2739</a>
<a href="http://poj.org/problem?id=2100">poj2100</a>
找到某一个区间使得区间内的数的和/平方和等于某一给定值k</p>
</blockquote>
<pre><code>
//poj2739
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include&lt;iostream&gt;
#define INF 0x3f3f3f3f
#define LL long long
#define N 10100
using namespace std;
int prime[N], tot;
bool vis[N];
int n;
void get_prime(int n)
{
	memset(vis, true, sizeof(vis));
	for (int i = 2; i &lt;= n; i++)
	{
		if (vis[i]){
			prime[++tot] = i;
			for (int j = i + i; j &lt;= n; j += i){
				vis[j] = false;
			}
		}
	}
}
int main()
{
	get_prime(10090);
	while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
	{
		int st = 1, en = 1,sum=0,ans=0;
		while (1)
		{
			while (sum &lt; n&amp;&amp;prime[en] &lt;= n) sum += prime[en++];
			if (sum == n) ans++;
			if (sum&lt;n) break;
			sum -= prime[st++];
		}
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}

</code></pre>
<pre><code>
//poj2100
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#define INF 0x3f3f3f3f
typedef long long ll;
#define N 10100
using namespace std;
typedef pair&lt;ll, ll&gt; P;
vector&lt;P&gt; ans;
ll n;
int main()
{
	while (cin &gt;&gt; n)
	{
		ans.clear();
		ll st = 1, en = 1;
		ll sum = 0;
		while (1)
		{
			while (sum &lt; n&amp;&amp;en*en &lt;= n)
				sum += en*en,en++;
			if (sum == n){
				ans.push_back(P(st, en));
			}
			if (sum &lt; n)
				break;
			sum -= st*st;
			st++;
		}
		printf(&quot;%d\n&quot;, ans.size());
		for (int i = 0; i &lt; ans.size(); i++)
		{
			P t = ans[i];
			printf(&quot;%lld&quot;, t.second - t.first);
			for (ll j = t.first; j &lt; t.second; j++)
				printf(&quot; %lld&quot;, j);
			printf(&quot;\n&quot;);
		}
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforce 1163 B Cat Party]]></title>
        <id>https://TheGayhub.github.io/post/codeforce-1163-b-cat-party</id>
        <link href="https://TheGayhub.github.io/post/codeforce-1163-b-cat-party">
        </link>
        <updated>2019-05-10T05:55:28.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="好题">好题</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="好题">好题</h1>
<!-- more -->
<blockquote>
<p>题目链接 <a href="https://codeforces.com/contest/1163/problem/B2">Cat Party</a></p>
</blockquote>
<blockquote>
<p>题目大致意思 题目会给出n天，每天都会有一个颜色<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，找出最大的<code>x</code>使<strong>删除前x天中的某一天</strong>，使得剩下的x-1天出现过的颜色个数相同</p>
</blockquote>
<p>如果<code>x</code>满足以下四个条件之一，那么这个<code>x</code>就是合法的。</p>
<ul>
<li>前<code>x</code>天内只出现过一种颜色</li>
<li>前<code>x</code>天内出现过x种颜色，每种颜色的个数为1</li>
<li>前<code>x</code>天内只有一种颜色出现过一次，既个数为1，其他若干种颜色的个数相同。</li>
<li>前<code>x</code>天内出现个数最多的颜色只有一种，其他种类的颜色个数相同，且这个最多个数的颜色比这些颜色个数多1</li>
</ul>
<p>可以发现，我们每次判断<code>x</code>是否合法几乎只与颜色个数为1的和颜色个数最多的那些颜色有关。所以我们就可用数组来保存这些颜色的信息，然后<code>O(1)</code>判断，总复杂度为<code>O(n)</code>.
具体看代码实现.</p>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;
int n, x,ans, mx, cnt[N], f[N];
//f[i] 颜色为i的个数
//cnt[i]表示个数为i的颜色的种类
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++)
	{
		scanf(&quot;%d&quot;, &amp;x);
		cnt[f[x]]--;//x要加1，所以原来种类的要减去1
		f[x]++;
		cnt[f[x]]++;
		mx = max(mx, f[x]);//保存出现最多的颜色的个数
		//每种颜色的个数都是1
		if (cnt[1] == i) ans = i;
		//只有一种颜色，i个
		else if (cnt[i] == 1) ans = i;
		//只有一种颜色个数是一，其他若干种颜色个数相同
		else if (cnt[1] == 1 &amp;&amp; cnt[mx] * mx == i - 1) ans = i;
		//个数最多的颜色的个数为mx,它的种类必须为1，并且比其他种类的颜色多1个，且其他种类的颜色的个数必须相同
		else if (cnt[mx - 1] * (mx - 1) == i - mx&amp;&amp;cnt[mx] == 1) ans = i;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Gym 101147 J-Whistle's New Car]]></title>
        <id>https://TheGayhub.github.io/post/codeforces-gym-101147-j-whistles-new-car</id>
        <link href="https://TheGayhub.github.io/post/codeforces-gym-101147-j-whistles-new-car">
        </link>
        <updated>2019-05-06T10:46:57.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="dfs">DFS</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="dfs">DFS</h1>
<!-- more -->
<blockquote>
<p>题目链接<a href="https://codeforces.com/gym/101147/problem/J"> Whistle's New Car</a></p>
</blockquote>
<p>题目的意思是给定 <code>n</code> 个城市编号 <code>1-n</code> ,每个城市都有一个权值    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
,两个城市间的距离  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_ {ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 这些城市的结构是一颗以 <code>1</code> 为根节点的树，输出每个城市<code>i</code>的<code>attractiveness</code>   ，每个节点 <code>attractiveness</code> 是满足以下条件的城市的个数</p>
<ol>
<li><code>j</code> 是 <code>i</code> 的子树。</li>
<li>在城市<code>j</code>加满 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">X_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的油后不再加油能到达 i 城市。</li>
</ol>
<p>主要思路：从根节点<code>1</code>出发DFS整棵树，我们用<code>s[i]</code>表示根节点到第<code>i</code>个节点的路径长度之和,(第 <strong><code>i</code></strong> 个节点貌似不恰当，可以理解为第 <strong><code>i</code></strong> 层).<code>num</code> 数组保存了我们 <code>dfs</code> 过程中之前所经过的城市(后面有用)。对于当前城市<code>i</code>它只能往上走，我们需要判断它能往上走到哪里,我们可以发现,对于在<code>i</code>之前的城市<code>j</code>如果满足  <strong><code>s[j]+x[i]&gt;=s[i]</code></strong> ，那么我们就可以从城市<code>i</code>走到城市<code>j</code>，因此我们需要找到最小的<code>j</code>，满足 <strong><code>s[j]&gt;=s[i]-x[i]</code></strong>  ,对于这个我们可以二分查找<code>s</code>数组，找到满足条件的最小的<code>j</code>,<code>j</code>城市满足条件，<code>j</code>到<code>i</code>路上所有的城市节点都满足条件(不包括i)，因此我们把<code>j,j+1....i-1</code>这些城市答案都加<code>1</code>，对于闭区间<code>[j~i-1]</code> 的值加上<code>1</code>，可以类似于差分来处理，<code>cnt[i-1]++</code>,<code>cnt[j-1]--</code>.这里让<code>cnt[j-1]--</code>，是为消除城市节点<code>j</code>之前的城市的影响，因为我们每次统计答案是<code>cnt[u] += cnt[v]</code> (<code>v</code>是<code>u</code>的孩子),对<code>[j~i-1]</code>之间的城市我们这样操作后它们的答案都会加<code>1</code>，但<code>j</code>之前的城市我们不能让它答案加<code>1</code>，因此我们<code>cnt[j-1]--</code>来消除这个影响。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
#define lowbit(x) (x&amp;(-x))
typedef long long ll;
const int N = 5e5 + 10;
int n;
ll a[N],s[N];
typedef pair&lt;int, ll&gt; P;
vector&lt;P&gt; p[N];
int cnt[N],num[N];
int ret;
void dfs(int u, int pre)
{
	for (auto E : p[u])
	{
		int v = E.first;
		ll w = E.second;
		if (v == pre) continue;
		s[ret] = s[ret - 1] + w;
		num[ret] = v; //路径上第ret城市为v
		int pos = lower_bound(s, s + ret + 1, s[ret] - a[v])-s;
		if (pos &lt; ret)//如果能到达父结点城市
		{
			cnt[u]++;
			if (pos) cnt[num[pos - 1]]--;//这个一定要减，不然后面节点的数加到父节点的时候，父节点就多加了
		}
		ret++;
		dfs(v, u);
		ret--;
		cnt[u] += cnt[v];
	}
}
int main()
{
	freopen(&quot;car.in&quot;, &quot;r&quot;, stdin);
	int T;
	scanf(&quot;%d&quot;, &amp;T);
	while (T--)
	{
		ret = 1;
		memset(cnt, 0, sizeof(cnt));
		scanf(&quot;%d&quot;, &amp;n);
		for (int i = 1; i &lt;= n; i++)
		{
			scanf(&quot;%lld&quot;, &amp;a[i]);
			p[i].clear();
		}
		for (int i = 1; i &lt; n; i++)
		{
			int u,v;
			ll w;
			scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;w);
			p[u].push_back(P(v, w));
			p[v].push_back(P(u, w));
		}
		ret = 1;
		num[0] = 1;
		s[0] = 0;
		dfs(1, -1);
		for (int i = 1; i &lt;= n; i++)
			printf(&quot;%d%c&quot;, cnt[i], i == n ? '\n' : ' ');
	}
	fclose(stdin);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforce Gym 101086 D - Secure but True]]></title>
        <id>https://TheGayhub.github.io/post/codeforce-gym-101086-d-secure-but-true</id>
        <link href="https://TheGayhub.github.io/post/codeforce-gym-101086-d-secure-but-true">
        </link>
        <updated>2019-05-05T10:03:08.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="思维模拟">思维+模拟</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="思维模拟">思维+模拟</h1>
<!-- more -->
<blockquote>
<p>题目链接 <a href="https://codeforces.com/gym/101086/problem/D">Secure but True </a></p>
</blockquote>
<blockquote>
<p>题目的大致意思是给出11个字符 <code>{A, H, I, M, O, T, U, V, W, X, Y},</code> ，这些字符可以任意结合组成字符串，这些字符串排序首先按照它们的长度排序，长度相同按照字典序排序，然后题目给你T个询问，每个询问给一个整数 <strong><code>k</code></strong> ，一个字符串 <strong><code>s</code></strong>   ，然后询问字符串s后的第k的字符串是什么。</p>
</blockquote>
<p>首先这11个字符可以组成无数个字符串，而k的范围又是1e9,所以不可能直接做。首先由11个字符先按照长度再按照字典序排可以想到10进制数，<strong><code>0-9 10-19 20-29</code></strong>  ,这 <strong><code>10</code></strong> 个数不正是先按照长度，再按照字典序来排的吗。于是这题也就和 <strong><code>11</code></strong> 进制相关，于是我和我队友想到了如下思路，将k转化为11进制，再将字符串s转化为11进制，<code>A-Y</code> 分别代表 <code>1-11</code>，然后相加，得到的结果再按照对应字符输出。
我们按照这个思路写了一下，然后交上去WA了，后来我们发现将k转化为11进制后会出现0，对于0我们无法处理，因为我们是把 <code>A-Y</code> 分别代表 <code>1-11</code> 来处理的，出现0我们就无法处理，于是我们就改了好长时间代码，还是没能正常处理0. 我们把Y当成0处理也不行，最后这题没能A掉。
比赛过后，我请教了一位大佬，就是用11进制做，A-Y仍分别代表1-11。然后模拟两个11进制相加。所以我们用短除法把k转为11进制这个方法错了。要用其他方法把k转化为11进制,并且不出现0，既每一位最低是1。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2e5 + 100;
string ss = &quot;AAHIMOTUVWXY&quot;;
typedef long long ll;
int to[128], k;
char s[N];
int a[N];
int b[N];
ll Pow[N];
void dfs(int x, int val)
{
	if (x&lt;0) return;
	for (int i = 1; i &lt;= 11; i++)
	{
		if (val &gt;= Pow[x]){
			val -= Pow[x];
		}
		else{
			b[x] = i;
			dfs(x - 1, val);
			break;
		}
	}
}
void Ac()
{
	memset(a, 0, sizeof(a));
	memset(b, 0, sizeof(b));
	scanf(&quot;%d%s&quot;, &amp;k, s);
	int len1 = strlen(s);
	for (int i = 0; i &lt; len1; i++)
		a[i] = to[s[i]];
	reverse(a, a + len1);
	int len2 = 0;
	//不能让0出现，这个处理保证了每一位最少是1 (与平时短除法转化不一样)
	for (int i = 0; i &lt;= 12; i++)
	{
		if (k &lt; Pow[i]){
			len2 = i;
			break;
		}
		else{
			//b[i]=1;
			k -= Pow[i];
		}
	}
	//这个dfs模拟转化11进制
	dfs(len2 - 1, k);
	//for (int i = 0; i &lt; len2; i++)
		//cout &lt;&lt; b[i] &lt;&lt; ' ';
	//cout &lt;&lt; endl;
	len1 = max(len1, len2);
	for (int i = 0; i &lt; len1; i++)
	{
		a[i] += b[i];
		while (a[i]&gt;11) a[i] -= 11, b[i + 1]++;
	}
	if (b[len1])  a[len1] += b[len1],len1++;
	for (int i = len1 - 1; i &gt;= 0; i--)
		putchar(ss[a[i]]);
	puts(&quot;&quot;);
}

int main(){
	int T;
	scanf(&quot;%d&quot;, &amp;T);
	Pow[0] = 1;
	for (int i = 1; i &lt;= 12; ++i)
		Pow[i] = Pow[i - 1] * 11;
	for (int i = 1; i &lt;= 11; i++)
		to[ss[i]] = i;
	while (T--)
		Ac();
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[POJ 2796 Feel Good]]></title>
        <id>https://TheGayhub.github.io/post/poj-2796-feel-good</id>
        <link href="https://TheGayhub.github.io/post/poj-2796-feel-good">
        </link>
        <updated>2019-05-04T11:36:58.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="单调栈">单调栈</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="单调栈">单调栈</h1>
<!-- more -->
<p><a href="http://poj.org/problem?id=2796">POJ 2796</a></p>
<p>题目的大致意思是，给你n个数，我们需要计算一个值，这个值是这个序列中的一段连续的子序列里的最小值乘于这段连续子序列的和，我们要使得求得的这个值最大，比如样例 <code>6 3 1 6 4 5 2</code>，我们选择<code>6 4 5</code>这段连续的子序列，值为<code>4*(6+4+5)=60</code>
首先对于每个数<code>a[i]</code>，我们想让他最大可能的往左右扩展，知道这个数往左和往右最大的扩展的坐标<code>l,r</code>,利用前缀和我们就求得了这个值<code>a[i]*(s[r]-s[l-1])</code>，所以这题在于我们怎么去求一个数往左右扩展的最大位置.
我们先以往右扩展为例，用 <strong><code>R[i]</code></strong>  表示 <strong><code>i</code></strong> 往右扩展的最大位置。我们建立一个单调栈，这个单调栈是单调递减的，即栈顶到栈底递减，用数组表示即是从左到右递增。我们扫描这个序列。</p>
<ul>
<li>如果当前这个数比栈顶大或者等于，我们直接入栈。</li>
<li>如果当前这个数比栈顶小，我们就从栈中弹出数，直到这个数比栈顶大，那怎么记录往右扩展的最大位置呢，我们在把数从栈中弹出的过程中，弹出的数一定比当前要入栈的数大，因此他一定不是最小的数，对后面没有作用，因此弹出的数最大扩展位置就是当前这个数的位置i再减去1,即<code>i-1</code>。
我们用<code>pos</code>数组记录一下栈中数所在的位置，同时<code>a[n+1]</code>设为<code>-1</code>，保证最后栈中元素都可以被弹出。
向左扩展也是一样道理。</li>
</ul>
<pre><code>#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;
int a[N], n, L[N], R[N], s[N], tot, pos[N];
ll sum[N];
pair&lt;int, int&gt; ans;
int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++){
        scanf(&quot;%d&quot;, &amp;a[i]);
        sum[i] = sum[i - 1] + 1LL*a[i];
        L[i] = R[i] = i;
    }
    a[n + 1] = -1;
    for (int i = 1; i &lt;= n+1; i++)
    {
        if (a[i] &gt;= s[tot])
            s[++tot] = a[i],pos[tot]=i;
        else{
            while (tot&amp;&amp;a[i] &lt; s[tot]){
                R[pos[tot]] = i - 1;
                tot--;
            }
            s[++tot] = a[i],pos[tot]=i;
        }
    }
    a[0] = -1,tot=0;
    for (int i = n; i &gt;= 0; i--){
        if (a[i] &gt;= s[tot]){
            s[++tot] = a[i],pos[tot]=i;
        }
        else{
            while (tot&amp;&amp; a[i] &lt; s[tot]){
                L[pos[tot]] = i+1;
                tot--;
            }
            s[++tot] = a[i], pos[tot] = i;
        }
    }
    ll max_val= -1;
    for (int i = 1; i &lt;= n; i++){
        if (a[i]*(sum[R[i]] - sum[L[i] - 1]) &gt; max_val)
        {
            max_val = a[i] * (sum[R[i]] - sum[L[i] - 1]);
            ans.first = L[i];
            ans.second = R[i];
        }
    }
    cout &lt;&lt; max_val &lt;&lt; endl;
    cout &lt;&lt; ans.first &lt;&lt; &quot; &quot; &lt;&lt; ans.second &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串最小表示法]]></title>
        <id>https://TheGayhub.github.io/post/MinString</id>
        <link href="https://TheGayhub.github.io/post/MinString">
        </link>
        <updated>2019-05-02T14:08:00.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="字符串最小表示法模板">字符串最小表示法模板</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="字符串最小表示法模板">字符串最小表示法模板</h1>
<!-- more -->
<blockquote>
<p>第一种</p>
</blockquote>
<pre><code>int get_minstring(char s[])
{
    int n =strlen(s);
    int i = 0, j = 1, k;
    while (i &lt; n&amp;&amp;j &lt; n)
    {
        for (k = 0; k &lt; n&amp;&amp;s[(j + k) % n] == s[(i + k) % n]; k++);
        if (k == n)  break;
        if (s[(i + k)%n]&gt;s[(j + k)%n])
        {
            i = i + k + 1;
            if (i == j) i++;
        }
        else
        {
            j = j + k + 1;
            if (i == j) j++;
        }
    }
    return min(i, j);
}

</code></pre>
<blockquote>
<p>第二种</p>
</blockquote>
<pre><code>int get_minstring(char s[])
{
    int n = strlen(s + 1);
    for (int i = 1; i &lt;= n; i++)
        s[n + i] = s[i];
    int i = 1, j = 2,k;
    while (i &lt;= n&amp;&amp;j &lt;= n)
    {
        for ( k = 0; k &lt; n&amp;&amp;s[j + k] == s[i + k]; k++);
        if (k == n)  break;
        if (s[i + k]&gt;s[j + k])
        {
            i = i + k + 1;
            if (i == j) i++;
        }
        else
        {
            j = j + k + 1;
            if (i == j) j++;
        }
    }
    return min(i, j);
}
</code></pre>
<p>这两个其实差不多</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速幂模板]]></title>
        <id>https://TheGayhub.github.io/post/fast_pow</id>
        <link href="https://TheGayhub.github.io/post/fast_pow">
        </link>
        <updated>2019-05-02T13:38:32.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="快速乘快速幂">快速乘+快速幂</h1>
<h1 id="计算-ab-p">计算   $ a^b $   % p</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="快速乘快速幂">快速乘+快速幂</h1>
<h1 id="计算-ab-p">计算   $ a^b $   % p</h1>
<!-- more -->
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
int t;
ll a, b, p;
ll fast_mul(ll a, ll b, ll p)
{
    ll res = 0;
    while (b)
    {
        if (b &amp; 1) res = (res + a) % p;
        a = a * 2 % p;
        b &gt;&gt;= 1;
    }
    return res;
}
ll fast_pow(ll a, ll b, ll p)
{
    ll res = 1;
    while (b)
    {
        if (b &amp; 1) res = fast_mul(res, a, p);
        a = fast_mul(a, a, p);
        b &gt;&gt;= 1;
    }
    return res;
}
int main()
{
    cin &gt;&gt; t;
    while (t--)
    {
        scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;p);
        printf(&quot;%lld\n&quot;, fast_pow(a, b, p));
    }

    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>